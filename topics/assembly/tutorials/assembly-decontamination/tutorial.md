---
layout: tutorial_hands_on

title: Decontamination of a genome assembly
zenodo_link: https://zenodo.org/records/13332983/files/Contaminated_assembly.fasta?download=1
questions:
- How to remove contaminant sequences from your assembly?
objectives:
- Remove contaminant sequences from an assembly
- Identify contaminant species
- Remove Mitochondrial DNA from an assembly
time_estimation: 1H30
key_points:
- Assembly decontamination is important to avoid false identification of genes, blast hits...
contributors:
- Delphine-L

---


# Introduction

<!-- This is a comment. -->
When sequencing a genome, it is common that a contamination from a foreign organism get mixed with the genomic material from our species of interest. The contamination may come from an infection or a  dirty sample for example. When building a reference genome, it is important to separate these contaminants from the genome of our species. Foreign DNA sequences could cause false positive identification when running a blast analyses, or cause the identification of genes that don't actually belong to the species etc. ...
In this tutorial, we will learn how to separate these contaminants from a the genome assembly of a vertebrate. It will also include the separation of mitochondrial DNA (Mitochondrial Genome Assembly can be found in another tutorial) so the genome assembly obtained in the end contain only nuclear DNA. 



> <agenda-title></agenda-title>
>
> In this tutorial, we will cover:
>
> 1. TOC
> {:toc}
>
{: .agenda}

# Get data

For this tutorial, we are using the genome assembly of the Zebra Finch (*aeniopygia guttata*) generated by the [Vertebrate Genome Project](https://vertebrategenomesproject.org/). We downsized the assembly to 50 of the largest scaffold to keep the running time reasonnable, and added some contaminants. 

This process will work with any assembly in fasta format. If your initial dataset is compressed, use the tool `Convert compressed file to uncompressed.` first.


> <hands-on-title> Data Upload </hands-on-title>
>
> 1. Create a new history for this tutorial
> 2. Import the files from [Zenodo]({{ page.zenodo_link }}):
>
>    ```
>    https://zenodo.org/records/13332983/files/Contaminated_assembly.fasta?download=1
>    ```
>    {% snippet faqs/galaxy/datasets_import_via_link.md %}
>
> 3. Rename the datasets : `Contaminated Assembly`
> 4. Check that the datatype is `fasta`
>
>    {% snippet faqs/galaxy/datasets_change_datatype.md datatype="fasta" %}
>
>
{: .hands_on}

# Genome Masking

Genome masking is the technique of hiding the region of the genome that cary low complexity, such as repeats. Masking a genome reduces the noise and improves the efficacy of the decontamination by emphasizing the regions that contribute the most to the classification{% cite saini2016gene %}{% cite maskedref-website %}. 
The first step of our analysis is therefore to mask our genome assembly. There is two type of masking, depending on the requirements of the tools we are using. 

- **Soft Masking** The masked regions are replaced by lower case letters
- **Hard Masking** The masked regions are replaced by a wildcard letter:  `N`s for nucleotide sequences, `X`s for proteins


> <details-title> Genome masking for everyone </details-title>
>
> Repeat masking is important for a lot of analyses like sequence alignments, classification, gene annotation. Repetitive and low complexity regions cause problems for search and clustering algorithms based on patterns. For gene annotation, repeats can cause non-specific gene hits. 
>
{: .details}

In this tutorial we will use Kraken2 to classify our scaffolds, and DustMasker to mask our genome. Dustmasker uses soft masking, while Kraken2 uses Hard masking, so we will do some file manipulations along the way. 

The first step is to ensure the sequences in our assembly are in upper cases. 


> <hands-on-title> Convert our assembly file to upper case </hands-on-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `Contaminated_assembly` 
>    - *"SED Program"*: `s/.*/\U&/` (Convert all letters to uppercase)
>
>    > <comment-title> Unsure about your regex? </comment-title>
>    >
>    > Ask ChatGPT about it. E.g. [What is the sed command to convert a text to upper case?](https://chatgpt.com/share/de569538-0e4d-41ac-8380-2d52af62b3d7)
>    {: .comment}
>
{: .hands_on}



> <hands-on-title> Mask the Genome with Dustmasker </hands-on-title>
>
> 1. {% tool [NCBI BLAST+ dustmasker](toolshed.g2.bx.psu.edu/repos/devteam/ncbi_blast_plus/ncbi_dustmasker_wrapper/2.14.1+galaxy1) %} with the following parameters:
>    - *"Subject database/sequences"*: `FASTA file from your history`
>        - {% icon param-file %} *"Nucleotide FASTA subject file to use instead of a database"*: `output` (output of **Text transformation** {% icon tool %})
>    - *"DUST level"*: `40`
>    - *"Output format"*: `FASTA`
>
>
>
{: .hands_on}


> <hands-on-title> Soft Masking to Hard Masking </hands-on-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `outfile` (output of **NCBI BLAST+ dustmasker** {% icon tool %})
>    - *"SED Program"*: `s/[a-z]/N/g`
> 
>
{: .hands_on}


# Identify Non-Target Contaminants

[Kraken2](https://ccb.jhu.edu/software/kraken2/) is a tool for taxonomic classification. It matches the kmer found in our seemblies to the ones stored in its databases. For the purpose of decontamination, we only need to identify possible contaminants, not the sequences belonging to our sampled organisms, we therefore only need to use a database containing likely contaminants such as bacteria, virus, and human (always wear gloves folks!). 
The best option at the time of this tutorial's writing is the PlusPF database which contains the RefSeq Standard (archaea, bacteria, viral, plasmid, human, UniVec_Core) plus protozoa and fungi data. 



> <hands-on-title> Identify the taxonomy of our sequences </hands-on-title>
>
> 1. {% tool [Kraken2](toolshed.g2.bx.psu.edu/repos/iuc/kraken2/kraken2/2.1.1+galaxy1) %} with the following parameters:
>    - *"Single or paired reads"*: `Single`
>        - {% icon param-file %} *"Input sequences"*: `output` (output of **Text transformation** {% icon tool %})
>    - *"Print scientific names instead of just taxids"*: `Yes`
>    - *"Confidence"*: `0.3`
>    - *"Split classified and unclassified outputs?"*: `Yes`
>    - *"Select a Kraken2 database"*: ``
>
>    ***TODO***: *Check parameter descriptions*
>
>    ***TODO***: *Consider adding a comment or tip box*
>
>
{: .hands_on}


Kraken provides us with three outputs : 
- A table containing the classification informations for each sequences
- A fasta file containing the classified sequences (our contaminants)
- A fasta file containing the unclassified sequences (our precious zebra finch)

We could decide to use the fasta file of unclassified sequences as our assembly, but remember that our genome is hard masked. That means that we lost information. Because we don't use it now doesn't mean we never will. So instead of using the masked genome, we will remove the classified sequences from our original assembly. 
 

But first, we are naturally curious people, and we want to know what type of contaminants we had in our sample. 


## Investigate our contaminants

> <hands-on-title> Extract classification informations </hands-on-title>
>
> 1. {% tool [Cut](Cut1) %} with the following parameters:
>    - *"Cut columns"*: `c1,c2,c3`
>    - *"Delimited by"*: `Tab`
>    - {% icon param-file %} *"From"*: `Kraken2 on data X: Classification` (output of **Kraken2** {% icon tool %})
>
>
>    > <comment-title> Columns definitions </comment-title>
>    >
>    > The three columns that we extracted contain: 
>    > 1. Wheter the sequence is classified `C` or unclassified `U`
>    > 2. The sequence name	
>    > 3. The sequence classification
>    >
>    {: .comment}
>
>    > <comment-title> What if my organism is in the database? </comment-title>
>    >
>    > If you can't find a database that include contaminants but exclude your organism, you will need to process the outputs of Kraken differently. Instead of filtering the sequences on classified/unclassified, select the sequences that do not match the taxonomic ID of your species. That is true for the rest of the section.
>    {: .comment}
>
{: .hands_on}


> <hands-on-title> Remove unclassified sequences </hands-on-title>
>
> 1. {% tool [Filter](Filter1) %} with the following parameters:
>    - {% icon param-file %} *"Filter"*: `Cut on data X` (output of **Cut** {% icon tool %})
>    - *"With following condition"*: `c1!='U'`
>
> 2. Rename the output `List of Contaminants`
>
{: .hands_on}


> <question-title></question-title>
>
>  How many different contaminants are in our sample?
>
> > <solution-title></solution-title>
> >
> >  We found two contaminants in our sample : Salmonella and Yersinia phage phiR1-37.
> >
> {: .solution}
>
{: .question}


## Get the list of contaminants to remove from our assembly

> <hands-on-title> Extract classified sequence headers </hands-on-title>
>
> 1. {% tool [Search in textfiles](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_grep_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"Select lines from"*: `Kraken2 on data X: Classified reads` (output of **Kraken2** {% icon tool %})
>    - *"Type of regex"*: `Basic`
>    - *"Regular Expression"*: `scaffold` to extract the fasta headers.
>
>
>
{: .hands_on}


> <hands-on-title> Convert contaminant sequence names to lower case to match the original assembly </hands-on-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `Search in textfiles on data X` (output of **Search in textfiles** {% icon tool %})
>    - *"SED Program"*: `s/[A-Z]/\L&/g`
>
{: .hands_on}

> <hands-on-title> Extract sequence names </hands-on-title>
>
> 1. {% tool [Replace](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_find_and_replace/9.3+galaxy1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `output` (output of **Text transformation** {% icon tool %})
>    - In *"Find and Replace"*:
>        - {% icon param-repeat %} *"Insert Find and Replace"*
>            - *"Find pattern"*: `>([a-z]+_[0-9]+) kraken:taxid\|[0-9]+`
>            - *"Replace with"*: `$1`
>            - *"Find-Pattern is a regular expression"*: `Yes`
>            - *"Replace all occurences of the pattern"*: `Yes`
>            - *"Find and Replace text in"*: `entire line`
>
>
{: .hands_on}

Now that we have our list of contaminants, we will go through a similar process to extract mitochondrial sequences. 


# Identify Mitochondrial DNA

We start with running Blastn against a database containing mitochondrial sequences.

> <hands-on-title> Blastn against RefSeq Mitochondrion </hands-on-title>
>
> 1. {% tool [NCBI BLAST+ blastn](toolshed.g2.bx.psu.edu/repos/devteam/ncbi_blast_plus/ncbi_blastn_wrapper/2.14.1+galaxy1) %} with the following parameters:
>    - {% icon param-file %} *"Nucleotide query sequence(s)"*: `output` (output of **Text transformation** {% icon tool %})
>    - *"Subject database/sequences"*: `Locally installed BLAST database`
>        - *"Nucleotide BLAST database"*: `RefSeq Mitochondrion`
>    - *"Type of BLAST"*: `blastn - Traditional BLASTN requiring an exact match of 11, for somewhat similar sequences`
>    - *"Output format"*: `Tabular (select which columns)`
>        - *"Standard columns"*: `qseqid, sseqid, length, qstart, qend, evalue`
>        - *"Extended columns"*: `qlen`
>        - *"Miscellaneous columns"*: `qcovs, qcovhsp`
>    - *"Advanced Options"*: `Hide Advanced Options`
>
>
{: .hands_on}


Next, we parse the result of the Blastn to extract a report on the alignements between our assemblies and the database, and a list of the scaffolds aligning with mitochonrial sequences. 


## Sub-step with **Parse mitochondrial blast**

> <hands-on-title> Task description </hands-on-title>
>
> 1. {% tool [Parse mitochondrial blast](toolshed.g2.bx.psu.edu/repos/iuc/parse_mito_blast/parse_mito_blast/1.0.2+galaxy0) %} with the following parameters:
>    - {% icon param-file %} *"Tabular file generated by mito-blast"*: `output1` (output of **NCBI BLAST+ blastn** {% icon tool %})
>
>
{: .hands_on}

Now that we have a list of mitochondrial scaffold, we will transform the scaffold names to lowercase to match the original assembly, as we did with the contaminant sequences. 


> <hands-on-title> Convert mitochondrial sequence names to lower case to match the original assembly </hands-on-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `mito_scaff_names` (output of **Parse mitochondrial blast** {% icon tool %})
>    - *"SED Program"*: `s/[A-Z]/\L&/g`
>    - *"Advanced Options"*: `Hide Advanced Options`
>
>
{: .hands_on}

# Remove contaminants and mitochondrial DNA from the assembly

From the previous sections, we obtain two files containing a list of sequences belonging to contaminants and one belonging to the mitochondria. We will merge these two lists to clean up our original assembly.


> <hands-on-title> Concatenate lists of scaffolds to remove </hands-on-title>
>
> 1. {% tool [Concatenate datasets](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_cat/0.1.1) %} with the following parameters:
>    - {% icon param-files %} *"Datasets to concatenate"*: `output` (output of **Text transformation** {% icon tool %}), `outfile` (output of **Replace** {% icon tool %})
>
>
{: .hands_on}


> <hands-on-title> Remove Scaffolds from the original genome assembly </hands-on-title>
>
> 1. {% tool [gfastats](toolshed.g2.bx.psu.edu/repos/bgruening/gfastats/gfastats/1.3.6+galaxy0) %} with the following parameters:
>    - {% icon param-file %} *"Input file"*: `output` (Input dataset)
>    - *"Specify target sequences"*: `Enabled`
>        - {% icon param-file %} *"Exclude specific intervals"*: `out_file1` (output of **Concatenate datasets** {% icon tool %})
>    - *"Tool mode"*: `Genome assembly manipulation`
>        - *"Output format"*: `FASTA.gz`
>
>
{: .hands_on}



# Conclusion

In this tutorial we used taxonomic classification to identified contaminants and Blast to identify mitochondrial sequences in a genome assembly. We then removed these sequences to keep only the nuclear DNA of our species of interest. 

Now that we have removed the contaminants and mitochondrial DNA from our assembly, it is ready for manual curation!

